#include <Arduino.h>

#include "screen.h"

#define KEYBD_DATA_PIN 4

/*
// clang-format off
const unsigned char scancode_to_apple[] = {
 //$0    $1    $2    $3    $4    $5    $6    $7    $8    $9    $A    $B    $C $D
$E    $F 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, //$00 0x00, 0x00, 0x00, 0x00, 0x00, 0xD1, 0xB1, 0x00,
0x00, 0x00, 0xDA, 0xD3, 0xC1, 0xD7, 0xB2, 0x00, //$10 0x00, 0xC3, 0xD8, 0xC4,
0xC5, 0xB4, 0xB3, 0x00, 0x00, 0xA0, 0xD6, 0xC6, 0xD4, 0xD2, 0xB5, 0x00, //$20
  0x00, 0xCE, 0xC2, 0xC8, 0xC7, 0xD9, 0xB6, 0x00, 0x00, 0x00, 0xCD, 0xCA, 0xD5,
0xB7, 0xB8, 0x00, //$30 0x00, 0xAC, 0xCB, 0xC9, 0xCF, 0xB0, 0xB9, 0x00, 0x00,
0xAE, 0xAF, 0xCC, 0xBB, 0xD0, 0xAD, 0x00, //$40 0x00, 0x00, 0xA7, 0x00, 0x00,
0xBD, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0x00, 0x00, //$50 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0xB1, 0x00, 0xB4, 0xB7, 0x00,
0x00, 0x00, //$60 0xB0, 0xAE, 0xB2, 0xB5, 0xB6, 0xB8, 0x9B, 0x00, 0x00, 0xAB,
0xB3, 0xAD, 0xAA, 0xB9, 0x00, 0x00,  //$70
  // High mirror, shift modified keys
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, //$80 0 0x00, 0x00, 0x00, 0x00, 0x00, 0xD1, 0xA1, 0x00, 0x00,
0x00, 0xDA, 0xD3, 0xC1, 0xD7, 0xC0, 0x00, //$90 1 0x00, 0xC3, 0xD8, 0xC4, 0xC5,
0xA4, 0xA3, 0x00, 0x00, 0xA0, 0xD6, 0xC6, 0xD4, 0xD2, 0xA5, 0x00, //$A0 2 0x00,
0xCE, 0xC2, 0xC8, 0xC7, 0xD9, 0xDE, 0x00, 0x00, 0x00, 0xCD, 0xCA, 0xD5, 0xA6,
0xAA, 0x00, //$B0 3 0x00, 0xBC, 0xCB, 0xC9, 0xCF, 0xA9, 0xA8, 0x00, 0x00, 0xBE,
0xBF, 0xCC, 0xBA, 0xD0, 0xAD, 0x00, //$C0 4 0x00, 0x00, 0xA2, 0x00, 0x00, 0xAB,
0x00, 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0x00, 0x00, //$D0 5 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0xB1, 0x00, 0xB4, 0xB7, 0x00, 0x00,
0x00, //$E0 6 0xB0, 0xAE, 0xB2, 0xB5, 0xB6, 0xB8, 0x9B, 0x00, 0x00, 0xAB, 0xB3,
0xAD, 0xAA, 0xB9, 0x00, 0x00  //$F0 7
};
// clang-format on
*//*
const unsigned char codes[] = {
    0x08: [0x7F, 0x7F, 0x7F], // BS/DELETE
    0x09: [0x09, 0x09, 0x09], // TAB
    0x0D: [0x0D, 0x0D, 0x0D], // CR
    0x10: [0xff, 0xff, 0xff], // SHIFT
    0x11: [0xff, 0xff, 0xff], // CTRL
    0x12: [0xff, 0xff, 0xff], // ALT/OPTION
    0x1B: [0x1B, 0x1B, 0x1B], // ESC
    // Most of these besides space won't happen
    0x20: [0x20, 0x20, 0x20], //
    0x25: [0x08, 0x08, 0x08], // <- left
    0x26: [0x0B, 0x0B, 0x0B], // ^ up
    0x27: [0x15, 0x15, 0x15], // -> right
    0x28: [0x0A, 0x0A, 0x0A], // v down
    0x29: [0x29, 0x29, 0x29], // )
    0x2A: [0x2A, 0x2A, 0x2A], // *
    0x2B: [0x2B, 0x2B, 0x2B], // +
    0x2C: [0x2C, 0x2C, 0x3C], // , - <
    0x2D: [0x2D, 0x2D, 0x5F], // - - _
    0x2E: [0x2E, 0x2E, 0x3E], // . - >
    0x2F: [0x2F, 0x2F, 0x3F], // / - ?

    0x30: [0x30, 0x30, 0x29], // 0 - )
    0x31: [0x31, 0x31, 0x21], // 1 - !
    0x32: [0x32, 0x00, 0x40], // 2 - @
    0x33: [0x33, 0x33, 0x23], // 3 - #
    0x34: [0x34, 0x34, 0x24], // 4 - $
    0x35: [0x35, 0x35, 0x25], // 5 - %
    0x36: [0x36, 0x36, 0x5E], // 6 - ^
    0x37: [0x37, 0x37, 0x26], // 7 - &
    0x38: [0x38, 0x38, 0x2A], // 8 - *
    0x39: [0x39, 0x39, 0x28], // 9 - (
    0x3A: [0x3A, 0x3A, 0x3A], // :
    0x3B: [0x3B, 0x3B, 0x3A], // ; - :
    0x3C: [0x3C, 0x3C, 0x3C], // <
    0x3D: [0x3D, 0x3D, 0x2B], // = - +
    0x3E: [0x3E, 0x3E, 0x3E], // >
    0x3F: [0x3F, 0x3F, 0x3F], // ?

    // Alpha and control
    0x40: [0x40, 0x00, 0x40], // @
    0x41: [0x61, 0x01, 0x41], // A
    0x42: [0x62, 0x02, 0x42], // B
    0x43: [0x63, 0x03, 0x43], // C - BRK
    0x44: [0x64, 0x04, 0x44], // D
    0x45: [0x65, 0x05, 0x45], // E
    0x46: [0x66, 0x06, 0x46], // F
    0x47: [0x67, 0x07, 0x47], // G - BELL
    0x48: [0x68, 0x08, 0x48], // H
    0x49: [0x69, 0x09, 0x49], // I - TAB
    0x4A: [0x6A, 0x0A, 0x4A], // J - NL
    0x4B: [0x6B, 0x0B, 0x4B], // K - VT
    0x4C: [0x6C, 0x0C, 0x4C], // L
    0x4D: [0x6D, 0x0D, 0x4D], // M - CR
    0x4E: [0x6E, 0x0E, 0x4E], // N
    0x4F: [0x6F, 0x0F, 0x4F], // O

    0x50: [0x70, 0x10, 0x50], // P
    0x51: [0x71, 0x11, 0x51], // Q
    0x52: [0x72, 0x12, 0x52], // R
    0x53: [0x73, 0x13, 0x53], // S
    0x54: [0x74, 0x14, 0x54], // T
    0x55: [0x75, 0x15, 0x55], // U
    0x56: [0x76, 0x16, 0x56], // V
    0x57: [0x77, 0x17, 0x57], // W
    0x58: [0x78, 0x18, 0x58], // X
    0x59: [0x79, 0x19, 0x59], // Y
    0x5A: [0x7A, 0x1A, 0x5A], // Z
    0x5B: [0xFF, 0xFF, 0xFF], // Left window
    0x5C: [0xFF, 0xFF, 0xFF], // Right window
    0x5D: [0xFF, 0xFF, 0xFF], // Select
    0x5E: [0x5E, 0x1E, 0x5E], //
    0x5F: [0x5F, 0x1F, 0x5F], // _

    // Numeric pad
    0x60: [0x30, 0x30, 0x30], // 0
    0x61: [0x31, 0x31, 0x31], // 1
    0x62: [0x32, 0x32, 0x32], // 2
    0x63: [0x33, 0x33, 0x33], // 3
    0x64: [0x34, 0x34, 0x34], // 4
    0x65: [0x35, 0x35, 0x35], // 5
    0x66: [0x36, 0x36, 0x36], // 6
    0x67: [0x37, 0x37, 0x37], // 7
    0x68: [0x38, 0x38, 0x38], // 8
    0x69: [0x39, 0x39, 0x39], // 9

    0x6A: [0x2A, 0x2A, 0x2A], // *
    0x6B: [0x2B, 0x2B, 0x2B], // +
    0x6D: [0x2D, 0x2D, 0x2D], // -
    0x6E: [0x2E, 0x2E, 0x2E], // .
    0x6F: [0x2F, 0x2F, 0x39], // /

    // Stray keys
    0xAD: [0x2D, 0x2D, 0x5F], // - - _
    0xBA: [0x3B, 0x3B, 0x3A], // ; - :
    0xBB: [0x3D, 0x3D, 0x2B], // = - +
    0xBC: [0x2C, 0x2C, 0x3C], // , - <
    0xBD: [0x2D, 0x2D, 0x5F], // - - _
    0xBE: [0x2E, 0x2E, 0x3E], // . - >
    0xBF: [0x2F, 0x2F, 0x3F], // / - ?
    0xC0: [0x60, 0x60, 0x7E], // ` - ~
    0xDB: [0x5B, 0x1B, 0x7B], // [ - {
    0xDC: [0x5C, 0x1C, 0x7C], // \ - |
    0xDD: [0x5D, 0x1D, 0x7D], // ] - }
    0xDE: [0x27, 0x22, 0x22], // ' - '

    };
    */
// keyboard scan buffer
unsigned short keyboard_data[3] = {0, 0, 0};
unsigned char keyboard_buf_indx = 0, keyboard_mbyte = 0;
bool shift_enabled = false;
bufRect lastKb = {0};
bufRect lastTm = {0};
// In apple II scancode format
volatile unsigned char keymem = 0;
bool flash = false;
unsigned char key_index = 0;
const char to_type[] =
  "10 DIM C : HGR\r"
  "20 FOR I=0 TO 159\r"
  "30 C=C+1:IF C = 8 THEN C = 1\r"
  "40 HCOLOR=C\r"
  "50 HPLOT 0,I TO 279,159-I\r"
  "60 NEXT I\r"
  "70 FOR I=279 TO 0 STEP -1\r"
  "80 C=C+1:IF C = 8 THEN C = 1\r"
  "90 HCOLOR=C\r"
  "100 HPLOT I,0 TO 279 - I,159\r"
  "110 NEXT I\r"
  "120 GOTO 20\r"
  "RUN\r"
  ;
const unsigned int num_chars = sizeof(to_type) / sizeof(char);

unsigned int kb_count = 0;
unsigned int last_kb = 0;

unsigned char keyboard_read() {
  unsigned int ms = millis();
  kb_count++;
  if (ms - last_kb > 50) {
    // Type a character
    last_kb = ms;
    if (key_index < num_chars) {
      keymem = 0x80 | to_type[key_index++];
    }
    kb_count = 0;
  }
  return keymem;
}

void keyboard_strobe() {
  keymem &= 0x7F;
}

// clock must be on digital 3
void keyboard_begin() {
  /*
  pinMode(3, INPUT_PULLUP);
  pinMode(KEYBD_DATA_PIN, INPUT_PULLUP);
  attachInterrupt(1, keyboard_bit, FALLING);
  */
}

void keyboard_bit() {
  /*
  if (digitalRead(KEYBD_DATA_PIN))
    keyboard_data[2] |= _BV(keyboard_buf_indx);
  else
    keyboard_data[2] &= ~(_BV(keyboard_buf_indx));
  if (++keyboard_buf_indx == 11) {
    // Ignore parity checks for now
    keyboard_data[2] = (keyboard_data[2] >> 1) & 0xFF;

    // extended keys
    if (keyboard_data[2] == 0xF0 || keyboard_data[2] == 0xE0)
      keyboard_mbyte = 1;
    else {
      // decrement counter for multibyte commands
      if (keyboard_mbyte)
        keyboard_mbyte--;
      // multibyte command is finished / normal command, process it
      if (!keyboard_mbyte) {
        if (keyboard_data[1] != 0xF0 && keyboard_data[1] != 0xE0) {
          // Standard keys
          if (keyboard_data[2] == 0x12 || keyboard_data[2] == 0x59)
            shift_enabled = true; // shift modifiers
          else
            keymem = pgm_read_byte_near(scancode_to_apple + keyboard_data[2] +
                                        ((shift_enabled) ? 0x80 : 0x00));
        } else if (keyboard_data[0] != 0xF0 && keyboard_data[1] == 0xE0) {
          // Extended keys
          if (keyboard_data[2] == 0x6B)
            keymem = 0x95; // back key
          if (keyboard_data[2] == 0x74)
            keymem = 0x88; // forward key
          // Power management keys, hardware reset
          if (keyboard_data[2] == 0x37) {
            // enable watchdog with min timeout
            // wait until reset
            wdt_enable(WDTO_15MS);
            for (;;)
              ;
          }
        } else if (keyboard_data[1] == 0xF0 &&
                   (keyboard_data[2] == 0x12 || keyboard_data[2] == 0x59))
          shift_enabled = false;
      }
    }

    // shuffle buffer
    keyboard_data[0] = keyboard_data[1];
    keyboard_data[1] = keyboard_data[2];
    keyboard_buf_indx = 0;
  }
  */
}
